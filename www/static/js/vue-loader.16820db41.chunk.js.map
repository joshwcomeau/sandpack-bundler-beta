{"version":3,"sources":["webpack:////Users/joshu/work/codesandbox-client/node_modules/vue-hot-reload-api/dist/index.js","webpack:///./src/sandbox/eval/transpilers/vue/v2/component-normalizer.js","webpack:///./src/sandbox/eval/transpilers/vue/v2/utils/gen-id.js","webpack:///./src/sandbox/eval/transpilers/vue/v2/loader.ts","webpack:///./src/sandbox/eval/transpilers/vue/v2/parser.js"],"names":["module","exports","cache","Object","create","sepRE","RegExp","path","sep","replace","genId","file","context","key","contextPath","split","length","relative","hash","getRawRequest","loaderContext","loaderUtils","getRemainingRequest","hotReloadAPIPath","defaultLang","template","styles","script","postcssExtensions","rewriterInjectRE","content","getRequire","getRequireString","getRequireForImport","getRequireForImportString","addCssModulesToLoader","buildCustomBlockLoaderString","stringifyLoaders","getLoaderString","getLangString","getRawLoaderString","ensureLoader","getSelectorString","ensureBang","a","loader","charAt","type","index","selectorPath","bustCache","lang","map","_","name","q","test","join","part","scoped","styleCompiler","styleCompilerPath","JSON","stringify","vue","id","moduleId","hasInlineConfig","query","postcss","loaders","indexOf","injectString","inject","Array","isArray","m","$1","defaultLoaders","html","css","attrs","preLoaders","postLoaders","_loaders","obj","options","noSrcAttrs","src","qs","querystring","option","cssModules","DEFAULT_OPTIONS","modules","OPTIONS","localIdentName","importLoaders","$2","parseQuery","assign","impt","depPath","stringifyRequest","addDependency","parse","rawPath","rawRequest","dependencyPromises","p","push","emitModule","vueHotReloadAPIRaw","filePath","_module","esModule","this","fileName","basename","sourceRoot","dirname","hashKey","output","parts","hasScoped","some","templateAttrs","hasComment","comments","functionalTemplate","functional","bubleTemplateOptions","buble","transforms","stripWithFunctional","templateCompilerOptions","transformToRequire","video","source","img","image","preserveWhitespace","compilerModules","undefined","codeSandboxLoaders","less","scss","sass","styl","stylus","ts","typescript","pug","coffee","styleLoaderPath","js","needsHotReload","styleInjectionCode","forEach","style","i","requireString","hasStyleLoader","invokeStyle","c","moduleName","emitError","Error","requirePath","componentNormalizerRaw","Promise","all","compiler","require","SourceMapGenerator","splitRE","emptyRE","generateSourceMap","filename","generated","setSourceContent","line","addMapping","original","column","toJSON","needMap","cacheKey","filenameWithHash","get","parseComponent","pad","set"],"mappings":"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","file":"static/js/vue-loader.16820db41.chunk.js","sourcesContent":["module.exports = \"var Vue // late bind\\nvar version\\nvar map = Object.create(null)\\nif (typeof window !== 'undefined') {\\n  window.__VUE_HOT_MAP__ = map\\n}\\nvar installed = false\\nvar isBrowserify = false\\nvar initHookName = 'beforeCreate'\\n\\nexports.install = function (vue, browserify) {\\n  if (installed) { return }\\n  installed = true\\n\\n  Vue = vue.__esModule ? vue.default : vue\\n  version = Vue.version.split('.').map(Number)\\n  isBrowserify = browserify\\n\\n  // compat with < 2.0.0-alpha.7\\n  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {\\n    initHookName = 'init'\\n  }\\n\\n  exports.compatible = version[0] >= 2\\n  if (!exports.compatible) {\\n    console.warn(\\n      '[HMR] You are using a version of vue-hot-reload-api that is ' +\\n        'only compatible with Vue.js core ^2.0.0.'\\n    )\\n    return\\n  }\\n}\\n\\n/**\\n * Create a record for a hot module, which keeps track of its constructor\\n * and instances\\n *\\n * @param {String} id\\n * @param {Object} options\\n */\\n\\nexports.createRecord = function (id, options) {\\n  if(map[id]) { return }\\n\\n  var Ctor = null\\n  if (typeof options === 'function') {\\n    Ctor = options\\n    options = Ctor.options\\n  }\\n  makeOptionsHot(id, options)\\n  map[id] = {\\n    Ctor: Ctor,\\n    options: options,\\n    instances: []\\n  }\\n}\\n\\n/**\\n * Check if module is recorded\\n *\\n * @param {String} id\\n */\\n\\nexports.isRecorded = function (id) {\\n  return typeof map[id] !== 'undefined'\\n}\\n\\n/**\\n * Make a Component options object hot.\\n *\\n * @param {String} id\\n * @param {Object} options\\n */\\n\\nfunction makeOptionsHot(id, options) {\\n  if (options.functional) {\\n    var render = options.render\\n    options.render = function (h, ctx) {\\n      var instances = map[id].instances\\n      if (ctx && instances.indexOf(ctx.parent) < 0) {\\n        instances.push(ctx.parent)\\n      }\\n      return render(h, ctx)\\n    }\\n  } else {\\n    injectHook(options, initHookName, function() {\\n      var record = map[id]\\n      if (!record.Ctor) {\\n        record.Ctor = this.constructor\\n      }\\n      record.instances.push(this)\\n    })\\n    injectHook(options, 'beforeDestroy', function() {\\n      var instances = map[id].instances\\n      instances.splice(instances.indexOf(this), 1)\\n    })\\n  }\\n}\\n\\n/**\\n * Inject a hook to a hot reloadable component so that\\n * we can keep track of it.\\n *\\n * @param {Object} options\\n * @param {String} name\\n * @param {Function} hook\\n */\\n\\nfunction injectHook(options, name, hook) {\\n  var existing = options[name]\\n  options[name] = existing\\n    ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook]\\n    : [hook]\\n}\\n\\nfunction tryWrap(fn) {\\n  return function (id, arg) {\\n    try {\\n      fn(id, arg)\\n    } catch (e) {\\n      console.error(e)\\n      console.warn(\\n        'Something went wrong during Vue component hot-reload. Full reload required.'\\n      )\\n    }\\n  }\\n}\\n\\nfunction updateOptions (oldOptions, newOptions) {\\n  for (var key in oldOptions) {\\n    if (!(key in newOptions)) {\\n      delete oldOptions[key]\\n    }\\n  }\\n  for (var key$1 in newOptions) {\\n    oldOptions[key$1] = newOptions[key$1]\\n  }\\n}\\n\\nexports.rerender = tryWrap(function (id, options) {\\n  var record = map[id]\\n  if (!options) {\\n    record.instances.slice().forEach(function (instance) {\\n      instance.$forceUpdate()\\n    })\\n    return\\n  }\\n  if (typeof options === 'function') {\\n    options = options.options\\n  }\\n  if (record.Ctor) {\\n    record.Ctor.options.render = options.render\\n    record.Ctor.options.staticRenderFns = options.staticRenderFns\\n    record.instances.slice().forEach(function (instance) {\\n      instance.$options.render = options.render\\n      instance.$options.staticRenderFns = options.staticRenderFns\\n      // reset static trees\\n      // pre 2.5, all static trees are cached together on the instance\\n      if (instance._staticTrees) {\\n        instance._staticTrees = []\\n      }\\n      // 2.5.0\\n      if (Array.isArray(record.Ctor.options.cached)) {\\n        record.Ctor.options.cached = []\\n      }\\n      // 2.5.3\\n      if (Array.isArray(instance.$options.cached)) {\\n        instance.$options.cached = []\\n      }\\n\\n      // post 2.5.4: v-once trees are cached on instance._staticTrees.\\n      // Pure static trees are cached on the staticRenderFns array\\n      // (both already reset above)\\n\\n      // 2.6: temporarily mark rendered scoped slots as unstable so that\\n      // child components can be forced to update\\n      var restore = patchScopedSlots(instance)\\n      instance.$forceUpdate()\\n      instance.$nextTick(restore)\\n    })\\n  } else {\\n    // functional or no instance created yet\\n    record.options.render = options.render\\n    record.options.staticRenderFns = options.staticRenderFns\\n\\n    // handle functional component re-render\\n    if (record.options.functional) {\\n      // rerender with full options\\n      if (Object.keys(options).length > 2) {\\n        updateOptions(record.options, options)\\n      } else {\\n        // template-only rerender.\\n        // need to inject the style injection code for CSS modules\\n        // to work properly.\\n        var injectStyles = record.options._injectStyles\\n        if (injectStyles) {\\n          var render = options.render\\n          record.options.render = function (h, ctx) {\\n            injectStyles.call(ctx)\\n            return render(h, ctx)\\n          }\\n        }\\n      }\\n      record.options._Ctor = null\\n      // 2.5.3\\n      if (Array.isArray(record.options.cached)) {\\n        record.options.cached = []\\n      }\\n      record.instances.slice().forEach(function (instance) {\\n        instance.$forceUpdate()\\n      })\\n    }\\n  }\\n})\\n\\nexports.reload = tryWrap(function (id, options) {\\n  var record = map[id]\\n  if (options) {\\n    if (typeof options === 'function') {\\n      options = options.options\\n    }\\n    makeOptionsHot(id, options)\\n    if (record.Ctor) {\\n      if (version[1] < 2) {\\n        // preserve pre 2.2 behavior for global mixin handling\\n        record.Ctor.extendOptions = options\\n      }\\n      var newCtor = record.Ctor.super.extend(options)\\n      record.Ctor.options = newCtor.options\\n      record.Ctor.cid = newCtor.cid\\n      record.Ctor.prototype = newCtor.prototype\\n      if (newCtor.release) {\\n        // temporary global mixin strategy used in < 2.0.0-alpha.6\\n        newCtor.release()\\n      }\\n    } else {\\n      updateOptions(record.options, options)\\n    }\\n  }\\n  record.instances.slice().forEach(function (instance) {\\n    if (instance.$vnode && instance.$vnode.context) {\\n      instance.$vnode.context.$forceUpdate()\\n    } else {\\n      console.warn(\\n        'Root or manually mounted instance modified. Full reload required.'\\n      )\\n    }\\n  })\\n})\\n\\n// 2.6 optimizes template-compiled scoped slots and skips updates if child\\n// only uses scoped slots. We need to patch the scoped slots resolving helper\\n// to temporarily mark all scoped slots as unstable in order to force child\\n// updates.\\nfunction patchScopedSlots (instance) {\\n  if (!instance._u) { return }\\n  // https://github.com/vuejs/vue/blob/dev/src/core/instance/render-helpers/resolve-scoped-slots.js\\n  var original = instance._u\\n  instance._u = function (slots) {\\n    try {\\n      // 2.6.4 ~ 2.6.6\\n      return original(slots, true)\\n    } catch (e) {\\n      // 2.5 / >= 2.6.7\\n      return original(slots, null, true)\\n    }\\n  }\\n  return function () {\\n    instance._u = original\\n  }\\n}\\n\"","module.exports = \"/* eslint-disable */\\n/* globals __VUE_SSR_CONTEXT__ */\\n\\n// IMPORTANT: Do NOT use ES2015 features in this file.\\n// This module is a runtime utility for cleaner component module output and will\\n// be included in the final webpack user bundle.\\n\\nmodule.exports = function normalizeComponent(\\n  rawScriptExports,\\n  compiledTemplate,\\n  functionalTemplate,\\n  injectStyles,\\n  scopeId,\\n  moduleIdentifier /* server only */\\n) {\\n  let scriptExports = (rawScriptExports = rawScriptExports || {});\\n\\n  // Vue.extend constructor export interop\\n  let defaultExport = scriptExports.default || scriptExports;\\n  let options =\\n    typeof defaultExport === 'function' ? defaultExport.options : defaultExport;\\n\\n  // render functions\\n  if (compiledTemplate) {\\n    options.render = compiledTemplate.render;\\n    options.staticRenderFns = compiledTemplate.staticRenderFns;\\n    options._compiled = true;\\n  }\\n\\n  // functional template\\n  if (functionalTemplate) {\\n    options.functional = true;\\n  }\\n\\n  // scopedId\\n  if (scopeId) {\\n    options._scopeId = scopeId;\\n  }\\n\\n  let hook;\\n  if (moduleIdentifier) {\\n    // server build\\n    hook = function (context) {\\n      // 2.3 injection\\n      context =\\n        context || // cached call\\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\\n      // 2.2 with runInNewContext: true\\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\\n        context = __VUE_SSR_CONTEXT__;\\n      }\\n      // inject component styles\\n      if (injectStyles) {\\n        injectStyles.call(this, context);\\n      }\\n      // register component module identifier for async chunk inferrence\\n      if (context && context._registeredComponents) {\\n        context._registeredComponents.add(moduleIdentifier);\\n      }\\n    };\\n    // used by ssr in case component is cached and beforeCreate\\n    // never gets called\\n    options._ssrRegister = hook;\\n  } else if (injectStyles) {\\n    hook = injectStyles;\\n  }\\n\\n  if (hook) {\\n    let functional = options.functional;\\n    let existing = functional ? options.render : options.beforeCreate;\\n\\n    if (!functional) {\\n      // inject component registration as beforeCreate hook\\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\\n    } else {\\n      // for template-only hot-reload because in that case the render fn doesn't\\n      // go through the normalizer\\n      options._injectStyles = hook;\\n      // register for functioal component in vue file\\n      options.render = function renderWithStyleInjection(h, context) {\\n        hook.call(context);\\n        return existing(h, context);\\n      };\\n    }\\n  }\\n\\n  return {\\n    exports: scriptExports,\\n    options: options,\\n  };\\n};\\n\"","// utility for generating a uid for each component file\n// used in scoped CSS rewriting\nimport path from 'path';\nimport hash from 'hash-sum';\n\nconst cache = Object.create(null);\nconst sepRE = new RegExp(path.sep.replace('\\\\', '\\\\\\\\'), 'g');\n\nexport default function genId(file, context, key) {\n  const contextPath = context.split(path.sep);\n  const rootId = contextPath[contextPath.length - 1];\n\n  /* eslint-disable */\n  file =\n    rootId +\n    '/' +\n    path.relative(context, file).replace(sepRE, '/') +\n    (key || '');\n  return cache[file] || (cache[file] = hash(file));\n}\n","// @flow\n/* eslint-disable import/no-webpack-loader-syntax, prefer-template, no-use-before-define, no-shadow, operator-assignment, no-else-return */\nimport querystring from 'querystring';\n\nimport { basename, dirname } from '@codesandbox/common/lib/utils/path';\n\nimport type { LoaderContext } from 'sandpack-core';\nimport loaderUtils from 'sandpack-core/lib/transpiler/utils/loader-utils';\n// @ts-ignore\nimport componentNormalizerRaw from '!raw-loader!./component-normalizer';\n// @ts-ignore\nimport vueHotReloadAPIRaw from '!raw-loader!vue-hot-reload-api';\n\nimport genId from './utils/gen-id';\nimport parse from './parser';\n\n// When extracting parts from the source vue file, we want to apply the\n// loaders chained before vue-loader, but exclude some loaders that simply\n// produces side effects such as linting.\nfunction getRawRequest(loaderContext) {\n  return loaderUtils.getRemainingRequest(loaderContext);\n}\n\nconst hotReloadAPIPath = '!noop-loader!/node_modules/vue-hot-reload-api.js';\nconst styleLoaderPath = 'vue-style-loader';\nconst templateCompilerPath = 'vue-template-compiler';\nconst styleCompilerPath = 'vue-style-compiler';\nconst selectorPath = 'vue-selector';\n\nconst defaultLang = {\n  template: 'html',\n  styles: 'css',\n  script: 'js',\n};\n\nconst postcssExtensions = ['postcss', 'pcss', 'sugarss', 'sss'];\n\nconst rewriterInjectRE = /\\b(css(?:-loader)?(?:\\?[^!]+)?)(?:!|$)/;\n\nexport default async function (content: string, loaderContext: LoaderContext) {\n  const dependencyPromises = [];\n  const addDependency = (p: string) => {\n    dependencyPromises.push(loaderContext.addDependency(p, options));\n  };\n\n  // Emit the vue-hot-reload-api so it's available in the sandbox\n  loaderContext.emitModule(\n    hotReloadAPIPath,\n    vueHotReloadAPIRaw,\n    '/',\n    false,\n    false\n  );\n\n  const path = loaderContext.path;\n  const query = loaderContext.options;\n  const filePath = loaderContext._module.module.path;\n  const options = {\n    // Always disable esModule as sandpack is CommonJS\n    esModule: false,\n    ...this.vue,\n    ...query,\n  };\n\n  const rawRequest = getRawRequest(loaderContext);\n  const fileName = basename(filePath);\n\n  const sourceRoot = dirname(path);\n  const moduleId = 'data-v-' + genId(path, options.context, options.hashKey);\n\n  const cssLoaderOptions = '?sourceMap';\n\n  let output = '';\n  const bustCache = true;\n\n  const parts = parse(content, fileName, false, sourceRoot);\n  const hasScoped = parts.styles.some(({ scoped }) => scoped);\n  const templateAttrs =\n    parts.template && parts.template.attrs && parts.template.attrs;\n  const hasComment = templateAttrs && templateAttrs.comments;\n  const functionalTemplate = templateAttrs && templateAttrs.functional;\n  const bubleTemplateOptions = { ...options.buble };\n  bubleTemplateOptions.transforms = { ...bubleTemplateOptions.transforms };\n  bubleTemplateOptions.transforms.stripWithFunctional = functionalTemplate;\n\n  const templateCompilerOptions =\n    '?' +\n    JSON.stringify({\n      id: moduleId,\n      hasScoped,\n      hasComment,\n      transformToRequire: {\n        video: 'src',\n        source: 'src',\n        img: 'src',\n        image: 'xlink:href',\n      },\n      preserveWhitespace: false,\n      buble: bubleTemplateOptions,\n      // only pass compilerModules if it's a path string\n      compilerModules:\n        typeof options.compilerModules === 'string'\n          ? options.compilerModules\n          : undefined,\n    });\n\n  const defaultLoaders = {\n    html: templateCompilerPath + templateCompilerOptions,\n    css: styleLoaderPath + '!css-loader' + cssLoaderOptions,\n    js: 'babel-loader',\n  };\n\n  const codeSandboxLoaders = {\n    less: ['vue-style-loader', 'css-loader', 'less-loader'],\n    scss: ['vue-style-loader', 'css-loader', 'sass-loader'],\n    sass: ['vue-style-loader', 'css-loader', 'sass-loader?indentedSyntax'],\n    styl: ['vue-style-loader', 'css-loader', 'stylus-loader'],\n    stylus: ['vue-style-loader', 'css-loader', 'stylus-loader'],\n    ts: ['ts-loader'],\n    typescript: ['ts-loader'],\n    pug: ['pug-loader'],\n    coffee: ['babel-loader', 'coffee-loader'],\n  };\n\n  const loaders = { ...defaultLoaders, ...codeSandboxLoaders };\n  const preLoaders = {};\n  const postLoaders = {};\n\n  const needsHotReload = parts.script || parts.template;\n  if (needsHotReload) {\n    output += 'var disposed = false\\n';\n  }\n\n  let cssModules;\n  if (parts.styles.length) {\n    let styleInjectionCode = 'function injectStyle (ssrContext) {\\n';\n    if (needsHotReload) {\n      styleInjectionCode += `  if (disposed) return\\n`;\n    }\n    parts.styles.forEach((style, i) => {\n      // require style\n      let requireString = style.src\n        ? getRequireForImport('styles', style, style.scoped)\n        : getRequire('styles', style, i, style.scoped);\n\n      const hasStyleLoader = requireString.indexOf('style-loader') > -1;\n      // const hasVueStyleLoader = requireString.indexOf('vue-style-loader') > -1;\n\n      const invokeStyle = c => `  ${c}\\n`;\n\n      const moduleName = style.module === true ? '$style' : style.module;\n      // setCssModule\n      if (moduleName) {\n        if (!cssModules) {\n          cssModules = {};\n          if (needsHotReload) {\n            output += `var cssModules = {}\\n`;\n          }\n        }\n\n        if (moduleName in cssModules) {\n          loaderContext.emitError(\n            new Error('CSS module name \"' + moduleName + '\" is not unique!')\n          );\n          styleInjectionCode += invokeStyle(requireString);\n        } else {\n          cssModules[moduleName] = true;\n\n          // `(vue-)style-loader` exposes the name-to-hash map directly\n          // `css-loader` exposes it in `.locals`\n          // add `.locals` if the user configured to not use style-loader.\n          if (!hasStyleLoader) {\n            requireString += '.locals';\n          }\n\n          if (!needsHotReload) {\n            styleInjectionCode += invokeStyle(\n              'this[\"' + moduleName + '\"] = ' + requireString\n            );\n          } else {\n            // handle hot reload for CSS modules.\n            // we store the exported locals in an object and proxy to it by\n            // defining getters inside component instances' lifecycle hook.\n            /* prettier-ignore */\n            styleInjectionCode +=\n            invokeStyle(`cssModules[\"${moduleName}\"] = ${requireString}`) +\n            `Object.defineProperty(this, \"${moduleName}\", { get: function () { return cssModules[\"${moduleName}\"] }})\\n`\n\n            const requirePath = style.src\n              ? getRequireForImportString('styles', style, style.scoped)\n              : getRequireString('styles', style, i, style.scoped);\n\n            output +=\n              `module.hot && module.hot.accept([${requirePath}], function () {\\n` +\n              // 1. check if style has been injected\n              `  var oldLocals = cssModules[\"${moduleName}\"]\\n` +\n              `  if (!oldLocals) return\\n` +\n              // 2. re-import (side effect: updates the <style>)\n              `  var newLocals = ${requireString}\\n` +\n              // 3. compare new and old locals to see if selectors changed\n              `  if (JSON.stringify(newLocals) === JSON.stringify(oldLocals)) return\\n` +\n              // 4. locals changed. Update and force re-render.\n              `  cssModules[\"${moduleName}\"] = newLocals\\n` +\n              `  require(\"${hotReloadAPIPath}\").rerender(\"${moduleId}\")\\n` +\n              `})\\n`;\n          }\n        }\n      } else {\n        styleInjectionCode += invokeStyle(requireString);\n      }\n    });\n    styleInjectionCode += '}\\n';\n    output += styleInjectionCode;\n  }\n\n  loaderContext.emitModule(\n    // No extension, so no transpilation !noop\n    '!noop-loader!/node_modules/component-normalizer.js',\n    componentNormalizerRaw,\n    '/',\n    false,\n    false\n  );\n\n  // we require the component normalizer function, and call it like so:\n  // normalizeComponent(\n  //   scriptExports,\n  //   compiledTemplate,\n  //   functionalTemplate,\n  //   injectStyles,\n  //   scopeId,\n  //   moduleIdentifier (server only)\n  // )\n  output +=\n    \"var normalizeComponent = require('!noop-loader!/node_modules/component-normalizer.js')\\n\";\n\n  // <script>\n  output += '  /* script */\\n  ';\n  const { script } = parts;\n  if (script) {\n    output +=\n      'var __vue_script__ = ' +\n      (script.src\n        ? getRequireForImport('script', script, false)\n        : getRequire('script', script, 0, false)) +\n      '\\n';\n\n    // inject loader interop\n    if (query.inject) {\n      output += '__vue_script__ = __vue_script__(injections)\\n';\n    }\n  } else {\n    output += 'var __vue_script__ = null\\n';\n  }\n\n  // <template>\n  output += '/* template */\\n';\n  const { template } = parts;\n  if (template) {\n    output +=\n      'var __vue_template__ = ' +\n      (template.src\n        ? getRequireForImport('template', template, false)\n        : getRequire('template', template, 0, false)) +\n      '\\n';\n  } else {\n    output += 'var __vue_template__ = null\\n';\n  }\n\n  // template functional\n  output += '/* template functional */\\n';\n  output +=\n    'var __vue_template_functional__ = ' +\n    (functionalTemplate ? 'true' : 'false') +\n    '\\n';\n\n  // style\n  output += '  /* styles */\\n  ';\n  output +=\n    'var __vue_styles__ = ' +\n    (parts.styles.length ? 'injectStyle' : 'null') +\n    '\\n';\n\n  // scopeId\n  output += '  /* scopeId */\\n  ';\n  output +=\n    'var __vue_scopeId__ = ' +\n    (hasScoped ? JSON.stringify(moduleId) : 'null') +\n    '\\n';\n\n  // moduleIdentifier (server only)\n  output += '/* moduleIdentifier (server only) */\\n';\n  output += 'var __vue_module_identifier__ = null\\n';\n\n  // close normalizeComponent call\n  output +=\n    'var Component = normalizeComponent(\\n' +\n    '  __vue_script__,\\n' +\n    '  __vue_template__,\\n' +\n    '  __vue_template_functional__,\\n' +\n    '  __vue_styles__,\\n' +\n    '  __vue_scopeId__,\\n' +\n    '  __vue_module_identifier__\\n' +\n    ')\\n';\n\n  // add filename in dev\n  output += 'Component.options.__file = ' + JSON.stringify(path) + '\\n';\n\n  if (!query.inject) {\n    // hot reload\n    if (needsHotReload) {\n      output +=\n        '\\n/* hot reload */\\n' +\n        'if (module.hot) {(function () {\\n' +\n        '  var hotAPI = require(\"' +\n        hotReloadAPIPath +\n        '\")\\n' +\n        '  hotAPI.install(require(\"vue\"), false)\\n' +\n        '  if (!hotAPI.compatible) return\\n' +\n        '  module.hot.accept()\\n' +\n        '  if (!module.hot.data) {\\n' +\n        // initial insert\n        '    hotAPI.createRecord(\"' +\n        moduleId +\n        '\", Component.options)\\n' +\n        '  } else {\\n';\n      // update\n      if (cssModules) {\n        output +=\n          '    if (module.hot.data.cssModules && Object.keys(module.hot.data.cssModules) !== Object.keys(cssModules)) {\\n' +\n          '      delete Component.options._Ctor\\n' +\n          '    }\\n';\n      }\n      output += `    hotAPI.${\n        functionalTemplate ? 'rerender' : 'reload'\n      }(\"${moduleId}\", Component.options)\\n  }\\n`;\n      // dispose\n      output +=\n        '  module.hot.dispose(function (data) {\\n' +\n        (cssModules ? '    data.cssModules = cssModules\\n' : '') +\n        '    disposed = true\\n' +\n        '  })\\n';\n      output += '})()}\\n';\n    }\n\n    // final export\n    output += '\\nmodule.exports = Component.exports\\n';\n  } else {\n    // inject-loader support\n    output =\n      '\\n/* dependency injection */\\n' +\n      'module.exports = function (injections) {\\n' +\n      output +\n      '\\n' +\n      '\\nreturn Component.exports\\n}';\n  }\n\n  await Promise.all(dependencyPromises);\n\n  // done\n  return output;\n\n  // --- helpers ---\n\n  function getRequire(type, part, index: number, scoped: boolean) {\n    return 'require(' + getRequireString(type, part, index, scoped) + ')';\n  }\n\n  function getRequireString(type, part, index: number, scoped: boolean) {\n    const rawPath =\n      '!!' +\n      // get loader string for pre-processors\n      getLoaderString(type, part, index, scoped) +\n      // // select the corresponding part from the vue file\n      getSelectorString(type, index || 0) +\n      // the url to the actual vue file, including remaining requests\n      // getFileName(type, part, index);\n      rawRequest;\n\n    // loaderContext.emitModule(rawPath, part.content, dirname(filePath), false, false);\n\n    const depPath = loaderUtils.stringifyRequest(loaderContext, rawPath);\n    addDependency(JSON.parse(depPath));\n\n    return depPath;\n  }\n\n  function getRequireForImport(type, impt, scoped: boolean) {\n    return 'require(' + getRequireForImportString(type, impt, scoped) + ')';\n  }\n\n  function getRequireForImportString(type, impt, scoped: boolean) {\n    const depPath = loaderUtils.stringifyRequest(\n      loaderContext,\n      '!!' + getLoaderString(type, impt, 0, scoped) + impt.src\n    );\n\n    addDependency(JSON.parse(depPath));\n\n    return depPath;\n  }\n\n  function addCssModulesToLoader(loader, part, index: number) {\n    if (!part.module) return loader;\n    const option = options.cssModules || {};\n    const DEFAULT_OPTIONS = {\n      modules: true,\n    };\n    const OPTIONS = {\n      localIdentName: '[hash:base64]',\n      importLoaders: true,\n    };\n    return loader.replace(/((?:^|!)css(?:-loader)?)(\\?[^!]*)?/, (m, $1, $2) => {\n      // $1: !css-loader\n      // $2: ?a=b\n      const q = loaderUtils.parseQuery($2 || '?');\n      Object.assign(q, OPTIONS, option, DEFAULT_OPTIONS);\n      if (index >= 0) {\n        // Note:\n        //   Class name is generated according to its filename.\n        //   Different <style> tags in the same .vue file may generate same names.\n        //   Append `_[index]` to class name to avoid this.\n        q.localIdentName += '_' + index;\n      }\n      return $1 + '?' + JSON.stringify(q);\n    });\n  }\n\n  function buildCustomBlockLoaderString(attrs) {\n    const noSrcAttrs = { ...attrs };\n    delete noSrcAttrs.src;\n    const qs = querystring.stringify(noSrcAttrs);\n    return qs ? '?' + qs : qs;\n  }\n\n  // stringify an Array of loader objects\n  function stringifyLoaders(_loaders) {\n    return _loaders\n      .map(obj =>\n        obj && typeof obj === 'object' && typeof obj.loader === 'string'\n          ? obj.loader + (obj.options ? '?' + JSON.stringify(obj.options) : '')\n          : obj\n      )\n      .join('!');\n  }\n\n  function getLoaderString(type, part, index: number, scoped: boolean) {\n    let loader = getRawLoaderString(type, part, index, scoped);\n    const lang = getLangString(type, part);\n    if (preLoaders[lang]) {\n      loader = loader + ensureBang(preLoaders[lang]);\n    }\n    if (postLoaders[lang]) {\n      loader = ensureBang(postLoaders[lang]) + loader;\n    }\n    return loader;\n  }\n\n  function getLangString(type, { lang }) {\n    if (type === 'script' || type === 'template' || type === 'styles') {\n      return lang || defaultLang[type];\n    } else {\n      return type;\n    }\n  }\n\n  function getRawLoaderString(type, part, index: number, scoped: boolean) {\n    let lang = part.lang || defaultLang[type];\n\n    let styleCompiler = '';\n    if (type === 'styles') {\n      // style compiler that needs to be applied for all styles\n      styleCompiler =\n        styleCompilerPath +\n        '?' +\n        JSON.stringify({\n          // a marker for vue-style-loader to know that this is an import from a vue file\n          vue: true,\n          id: moduleId,\n          scoped: !!scoped,\n          hasInlineConfig: !!query.postcss,\n        }) +\n        '!';\n      // normalize scss/sass/postcss if no specific loaders have been provided\n      if (!loaders[lang]) {\n        if (postcssExtensions.indexOf(lang) !== -1) {\n          lang = 'css';\n        } else if (lang === 'sass') {\n          lang = 'sass?indentedSyntax';\n        } else if (lang === 'scss') {\n          lang = 'scss';\n        }\n      }\n    }\n\n    let loader = loaders[lang];\n\n    const injectString =\n      type === 'script' && query.inject ? 'inject-loader!' : '';\n\n    if (loader != null) {\n      if (Array.isArray(loader)) {\n        loader = stringifyLoaders(loader);\n      } else if (typeof loader === 'object') {\n        loader = stringifyLoaders([loader]);\n      }\n      if (type === 'styles') {\n        // add css modules\n        loader = addCssModulesToLoader(loader, part, index);\n        // inject rewriter before css loader for extractTextPlugin use cases\n        if (rewriterInjectRE.test(loader)) {\n          loader = loader.replace(\n            rewriterInjectRE,\n            (m, $1) => ensureBang($1) + styleCompiler\n          );\n        } else {\n          loader = ensureBang(loader) + styleCompiler;\n        }\n      }\n      // if user defines custom loaders for html, add template compiler to it\n      if (type === 'template' && loader.indexOf(defaultLoaders.html) < 0) {\n        loader = defaultLoaders.html + '!' + loader;\n      }\n      return injectString + ensureBang(loader);\n    } else {\n      // unknown lang, infer the loader to be used\n      switch (type) {\n        case 'template':\n          return defaultLoaders.html + '!';\n        case 'styles':\n          loader = addCssModulesToLoader(defaultLoaders.css, part, index);\n          return loader + '!' + styleCompiler + ensureBang(ensureLoader(lang));\n        case 'script':\n          return injectString + ensureBang(ensureLoader(lang));\n        default:\n          loader = loaders[type];\n          if (Array.isArray(loader)) {\n            loader = stringifyLoaders(loader);\n          }\n          return ensureBang(loader + buildCustomBlockLoaderString(part.attrs));\n      }\n    }\n  }\n\n  // sass => sass-loader\n  // sass-loader => sass-loader\n  // sass?indentedSyntax!css => sass-loader?indentedSyntax!css-loader\n  function ensureLoader(lang) {\n    return lang\n      .split('!')\n      .map(loader =>\n        loader.replace(\n          /^([\\w-]+)(\\?.*)?/,\n          (_, name, q) =>\n            (/-loader$/.test(name) ? name : name + '-loader') + (q || '')\n        )\n      )\n      .join('!');\n  }\n\n  function getSelectorString(type: string, index: number) {\n    return (\n      selectorPath +\n      '?type=' +\n      (type === 'script' || type === 'template' || type === 'styles'\n        ? type\n        : 'customBlocks') +\n      '&index=' +\n      index +\n      (bustCache ? '&bustCache' : '') +\n      '!'\n    );\n  }\n\n  function ensureBang(loader) {\n    if (loader.charAt(loader.length - 1) !== '!') {\n      return loader + '!';\n    } else {\n      return loader;\n    }\n  }\n}\n","/* eslint-disable */\nconst compiler = require('vue-template-compiler');\nconst cache = require('lru-cache')(100);\nconst hash = require('hash-sum');\nconst SourceMapGenerator = require('source-map').SourceMapGenerator;\n\nconst splitRE = /\\r?\\n/g;\nconst emptyRE = /^(?:\\/\\/)?\\s*$/;\n\nmodule.exports = function(content, filename, needMap, sourceRoot) {\n  const cacheKey = hash(filename + content);\n  // source-map cache busting for hot-reloadded modules\n  const filenameWithHash = filename + '?' + cacheKey;\n  let output = cache.get(cacheKey);\n  if (output) return output;\n  output = compiler.parseComponent(content, { pad: 'line' });\n  if (needMap) {\n    if (output.script && !output.script.src) {\n      output.script.map = generateSourceMap(\n        filenameWithHash,\n        content,\n        output.script.content,\n        sourceRoot\n      );\n    }\n    if (output.styles) {\n      output.styles.forEach(style => {\n        if (!style.src) {\n          style.map = generateSourceMap(\n            filenameWithHash,\n            content,\n            style.content,\n            sourceRoot\n          );\n        }\n      });\n    }\n  }\n  cache.set(cacheKey, output);\n  return output;\n};\n\nfunction generateSourceMap(filename, source, generated, sourceRoot) {\n  const map = new SourceMapGenerator({ sourceRoot });\n  map.setSourceContent(filename, source);\n  generated.split(splitRE).forEach((line, index) => {\n    if (!emptyRE.test(line)) {\n      map.addMapping({\n        source: filename,\n        original: {\n          line: index + 1,\n          column: 0,\n        },\n        generated: {\n          line: index + 1,\n          column: 0,\n        },\n      });\n    }\n  });\n  return map.toJSON();\n}\n"],"sourceRoot":""}